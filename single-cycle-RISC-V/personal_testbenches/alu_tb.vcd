$date
	Mon Oct 17 17:11:45 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module alu_tb $end
$var wire 5 ! shamt [4:0] $end
$var wire 5 " rs2 [4:0] $end
$var wire 5 # rs1 [4:0] $end
$var wire 5 $ rd [4:0] $end
$var wire 10 % optype [9:0] $end
$var wire 7 & opcode [6:0] $end
$var wire 32 ' imm [31:0] $end
$var wire 7 ( funct7 [6:0] $end
$var wire 3 ) funct3 [2:0] $end
$var wire 32 * alu_out [31:0] $end
$var reg 1 + B_sel $end
$var reg 4 , alu_sel [3:0] $end
$var reg 32 - data_A [31:0] $end
$var reg 32 . data_B [31:0] $end
$var reg 32 / inst [31:0] $end
$scope module decoder_0 $end
$var wire 32 0 insn [31:0] $end
$var wire 5 1 shamt [4:0] $end
$var wire 5 2 rs2 [4:0] $end
$var wire 5 3 rs1 [4:0] $end
$var wire 5 4 rd [4:0] $end
$var wire 7 5 opcode [6:0] $end
$var wire 7 6 funct7 [6:0] $end
$var wire 3 7 funct3 [2:0] $end
$upscope $end
$scope module dut $end
$var wire 1 + B_sel $end
$var wire 4 8 alu_sel [3:0] $end
$var wire 32 9 data_A [31:0] $end
$var wire 32 : data_B [31:0] $end
$var wire 5 ; shamt [4:0] $end
$var wire 32 < alu_out [31:0] $end
$upscope $end
$scope module immgen_0 $end
$var wire 1 = U $end
$var wire 32 > insn [31:0] $end
$var wire 10 ? optype [9:0] $end
$var wire 32 @ imm [31:0] $end
$var wire 1 A S $end
$var wire 1 B J $end
$var wire 1 C B $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0C
0B
0A
b10100011111 @
b100 ?
b1010001111100011000000110010011 >
0=
b110011001100110011100001010010 <
b11111 ;
b10100011111 :
b110011001100110011001100110011 9
b0 8
b0 7
b101000 6
b10011 5
b11 4
b11 3
b11111 2
b11111 1
b1010001111100011000000110010011 0
b1010001111100011000000110010011 /
b10100011111 .
b110011001100110011001100110011 -
b0 ,
1+
b110011001100110011100001010010 *
b0 )
b101000 (
b10100011111 '
b10011 &
b100 %
b11 $
b11 #
b11111 "
b11111 !
$end
#10
b111 ,
b111 8
b10000001100 '
b10000001100 @
b11111111111110011001100110011001 *
b11111111111110011001100110011001 <
b10010 $
b10010 4
b101 )
b101 7
b1001 #
b1001 3
b1100 "
b1100 2
b100000 (
b100000 6
b1100 !
b1100 1
b1100 ;
b1100 .
b1100 :
b10011001100110011001100110011001 -
b10011001100110011001100110011001 9
b1000000110001001101100100010011 /
b1000000110001001101100100010011 0
b1000000110001001101100100010011 >
#20
b10001000000000000000000000000000 *
b10001000000000000000000000000000 <
b1 %
b1 ?
b101 ,
b101 8
0+
b1001 '
b1001 @
b110011 &
b110011 5
b1 )
b1 7
b100 #
b100 3
b1001 "
b1001 2
b0 (
b0 6
b1001 !
b1001 1
b1001 ;
b10011001100110011001100110011001 .
b10011001100110011001100110011001 :
b1000100010001000100010001000100 -
b1000100010001000100010001000100 9
b100100100001100100110011 /
b100100100001100100110011 0
b100100100001100100110011 >
#30
b10001 *
b10001 <
b110 ,
b110 8
b1100 $
b1100 4
b101 )
b101 7
b10 #
b10 3
b100010001000100010001000100010 -
b100010001000100010001000100010 9
b100100010101011000110011 /
b100100010101011000110011 0
b100100010101011000110011 >
#40
b11001 *
b11001 <
b111 ,
b111 8
b10000001001 '
b10000001001 @
b1110 $
b1110 4
b11 #
b11 3
b100000 (
b100000 6
b110011001100110011001100110011 -
b110011001100110011001100110011 9
b1000000100100011101011100110011 /
b1000000100100011101011100110011 0
b1000000100100011101011100110011 >
#50
